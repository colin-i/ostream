
#name: appimage

on:
 # Triggers the workflow on push or pull request events but only for the main branch
 #push:
 # branches: [ main ]
 #pull_request:
 # branches: [ main ]
 # Allows you to run this workflow manually from the Actions tab
 workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
 # This workflow contains a single job called "build"
 build:
  # The type of runner that the job will run on
  runs-on: ubuntu-18.04
  # Steps represent a sequence of tasks that will be executed as part of the job
  steps:
   # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
   #- uses: actions/checkout@v3
   #with:
   # repository: colin-i/irc
   # path: my-tools
   #- uses: dsaltares/fetch-gh-release-asset@master
   #this is locally: throw new Error("Parameter token or opts.auth is required");
   #  with:
   #   repo: 'colin-i/test'
   #   file: 'ovideo.png'
   #   target: 'in/' #plague-linux.zip'
   # #version: 'tags/1.1'
   # #token: ${{ secrets.PAT }}
   #Runs a set of commands using the runners shell
   - name: Run a multi-line script
     run: |
      if [ -n "${{ env.init }}" ]; then
       exit
      fi
      mkdir -p AppDir
      file=runtime
      if [ ! -e "${file}" ]; then
       arch=-x86_64
       archfile=${file}${arch}
       urlpart=`wget -q https://github.com/AppImage/AppImageKit/releases/latest -O - | grep "${archfile}" | head -n 1 | cut -d '"' -f 2`
       #"pkg2appimage-.*-x86_64.AppImage"
       wget -c https://github.com/${urlpart}
       mv ${archfile} ${file}
       chmod a+x ${file}
       file2=AppRun
       archfile2=${file2}${arch}
       urlpart=${urlpart:0:`echo ${urlpart} | grep -ob '[^/]*$' | cut -d ':' -f 1`}${archfile2}
       wget -c https://github.com/${urlpart}
       chmod a+x ${archfile2}
       mv ${archfile2} AppDir/${file2}
      fi
      downdeb () {
       maindeb=${2}.deb
       if [ ! -e "${maindeb}" ]; then
        wget http://${1}/ubuntu/dists/bionic/main/binary-${3}/Packages.xz -O Packages.xz
        xz -fd Packages.xz #f for multiple times
        debfilename=`grep "^Filename.*${2}" Packages | tail -1 | cut -d ' ' -f 2`
        wget_url=http://${1}/ubuntu/${debfilename}
        #https://launchpad.net/~colin-i/+archive/ubuntu/ppa/+files/${debfilename}	| grep -o '[^/]*$'
        wget ${wget_url} -O ${maindeb}
        ar x ${2}.deb data.tar.xz
        xz -fd data.tar.xz
        tar -xf data.tar -C AppDir
       fi
      }
      downdeb "ppa.launchpadcontent.net/colin-i/ppa" ovideo i386
      downdeb "ro.archive.ubuntu.com" libc6-i386 amd64
      cd AppDir
      pngfile=ovideo.png
      if [ ! -e "${pngfile}" ]; then
       wget https://github.com/colin-i/test/releases/download/1.1/ovideo.png -O ${pngfile} #O for multiple times
       ln -s ${pngfile} .DirIcon #f for multiple times
      fi
      cat > ovideo.desktop <<EOF
      [Desktop Entry]
      Type=Application
      Name=OVideo
      Exec=ovideo
      Icon=ovideo
      Categories=GNOME;GTK;
      EOF
      if [ ! -e "usr/bin/ostream" ]; then
      cd usr/bin
       mv ovideo ostream
       #live64 is not having /lib/ld-linux.so.2. without librarypath will wrong libc bionic to jammy
       cat > ovideo <<EOF
      #!/bin/bash
      cd "\$(dirname "\$0")"
      ../../lib32/ld-linux.so.2 --library-path ../../lib32 ./ostream
      EOF
       chmod 755 ovideo
       cd ../../
      fi
      cd ..
      mksquashfs AppDir ovideo.squashfs -root-owned -noappend
      cat runtime >> ovideo.AppImage
      cat ovideo.squashfs >> ovideo.AppImage
      chmod a+x ovideo.AppImage
      #http://ro.archive.ubuntu.com/ubuntu/dists/bionic/main/binary-i386/Packages.xz
      #https://stackoverflow.com/questions/9981099/are-exported-private-keys-in-gpg-still-encrypted
      #echo -n ${{ secrets.PASS }} > pas.txt
      #echo "tag=refs/tags/1.1" >> $GITHUB_ENV
      #echo $tag ${{ env.tag }}
      #ARCH=i686 ${file} ./ovideo.yml
   #- name: Create Release
   #  id: create_release
   #  uses: actions/create-release@v1
   #  env:
   #   GITHUB_TOKEN: ${{ secrets.PAT }}
   #  with:
   #   tag_name: ${{ env.tag }}
   #   release_name: Release ${{ env.tag }}
   #   draft: false
   #   rerelease: false
   #- name: Upload Release Asset
   #  uses: actions/upload-release-asset@v1
   #  env:
   #   GITHUB_TOKEN: ${{ secrets.PAT }}
   #  with:
   #   upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps
   #   asset_path: ./LD-.glibc2.27-x86_64.AppImage
   #   asset_name: LD-.glibc2.27-x86_64.AppImage
   #   asset_content_type: application/x-executable
